/*
 * vim: tabstop=8 shiftwidth=2 noexpandtab softtabstop=2 cinoptions=>2,{2,:0,t0,(0,W4
 *
 * <copyright_assignments>
 * Copyright (C) 2008  Robert Bragg
 * </copyright_assignments>
 *
 * <license>
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA  02110-1301, USA.
 * </license>
 *
 */

#include <gx/gx-pixmap.h>
#include <gx/gx-connection.h>
#include <gx/gx-protocol-error.h>

#include <string.h>

/* Macros and defines */
#define GX_PIXMAP_GET_PRIVATE(object) \
    (G_TYPE_INSTANCE_GET_PRIVATE ((object), GX_TYPE_PIXMAP, GXPixmapPrivate))

#if 0
enum
{
  SIGNAL_NAME,
  LAST_SIGNAL
};
#endif

enum
{
  PROP_0,
  PROP_WRAP_XID,
  PROP_DEPTH,
  PROP_DRAWABLE,
  PROP_WIDTH,
  PROP_HEIGHT
};

struct _GXPixmapPrivate
{
  /* NB: I think it will lead to trouble if we try and maintain these
   * properties as anything other than write once - construct only
   * properties.
   *
   * Like XCB we should not try and provide any caching of state, instead
   * we can leave that to higher levels.
   *
   * Also you can't implement such properties via autogenerated code,
   * so you could only hope for a limited amount of sugar.
   */
  gint8 depth_construct;
  GXDrawable *drawable_construct;
  gboolean wrap_construct;
  guint16 width_construct;
  guint16 height_construct;
};


static void gx_pixmap_get_property (GObject * object,
				    guint id,
				    GValue * value, GParamSpec * pspec);
static void gx_pixmap_set_property (GObject * object,
				    guint property_id,
				    const GValue * value, GParamSpec * pspec);
/* static void gx_pixmap_mydoable_interface_init(gpointer interface,
   gpointer data); */
static void gx_pixmap_init (GXPixmap * self);
static GObject *
gx_pixmap_constructor (GType type,
		       guint n_construct_params,
		       GObjectConstructParam *construct_params);

static void gx_pixmap_finalize (GObject * self);


/* Variables */
static GXDrawableClass *parent_class = NULL;
/* static guint gx_pixmap_signals[LAST_SIGNAL] = { 0 }; */

G_DEFINE_TYPE (GXPixmap, gx_pixmap, GX_TYPE_DRAWABLE);

static GHashTable *xid_to_pixmap_map = NULL;

static void
gx_pixmap_class_init (GXPixmapClass * klass)	/* Class Initialization */
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
  GParamSpec   *new_param;

  parent_class = g_type_class_peek_parent (klass);

  gobject_class->finalize = gx_pixmap_finalize;

  gobject_class->get_property = gx_pixmap_get_property;
  gobject_class->set_property = gx_pixmap_set_property;

  gobject_class->constructor = gx_pixmap_constructor;

  /* FIXME - mutex */
  if (!xid_to_pixmap_map)
    {
      xid_to_pixmap_map = g_hash_table_new (g_direct_hash, g_direct_equal);
    }

  new_param = g_param_spec_boolean("wrap", /* name */
				   "Wrap",	/* nick name */
				   "Simply wrap an already existing xid",
				   FALSE, /* default */
				   G_PARAM_WRITABLE
				   | G_PARAM_CONSTRUCT_ONLY);
  g_object_class_install_property (gobject_class, PROP_WRAP_XID, new_param);

  new_param = g_param_spec_uint ("depth", /* name */
			         "Depth", /* nick name */
			         "Window Depth", /* description */
			         0, /* minimum */
			         G_MAXUINT8, /* maximum */
			         0, /* default */
			         G_PARAM_WRITABLE
			         | G_PARAM_CONSTRUCT_ONLY);
  g_object_class_install_property (gobject_class, PROP_DEPTH, new_param);

  new_param = g_param_spec_object("drawable", /* name */
				  "Drawable",	/* nick name */
				  "Reference Drawable",	/* description */
				  GX_TYPE_DRAWABLE,	/* GType */
				  G_PARAM_WRITABLE	/* flags */
				  | G_PARAM_CONSTRUCT_ONLY);
  g_object_class_install_property (gobject_class, PROP_DRAWABLE, new_param);

  new_param = g_param_spec_uint("width", /* name */
			       "Width",	/* nick name */
			       "Window width",	/* description */
			       1,	/* minimum */
			       G_MAXUINT16,	/* maximum */
			       1,	/* default */
			       G_PARAM_WRITABLE
			       | G_PARAM_CONSTRUCT_ONLY);
  g_object_class_install_property (gobject_class, PROP_WIDTH, new_param);

  new_param = g_param_spec_uint ("height", /* name */
			         "Height", /* nick name */
			         "Window height", /* description */
			         1, /* minimum */
			         G_MAXUINT16, /* maximum */
			         1, /* default */
			         G_PARAM_WRITABLE
			         | G_PARAM_CONSTRUCT_ONLY);
  g_object_class_install_property (gobject_class, PROP_HEIGHT, new_param);

  /* set up signals */
#if 0 /* template code */
  klass->signal_member = signal_default_handler;
  gx_pixmap_signals[SIGNAL_NAME] =
    g_signal_new ("signal_name", /* name */
		  G_TYPE_FROM_CLASS(klass), /* interface GType */
		  G_SIGNAL_RUN_LAST, /* signal flags */
		  G_STRUCT_OFFSET(GXPixmapClass, signal_member),
		  NULL, /* accumulator */
		  NULL, /* accumulator data */
		  g_cclosure_marshal_VOID__VOID, /* c marshaller */
		  G_TYPE_NONE, /* return type */
		  0 /* number of parameters */
		  /* vararg, list of param types */
    );
#endif

  g_type_class_add_private (klass, sizeof (GXPixmapPrivate));
}

static void
gx_pixmap_get_property (GObject * object,
			guint id, GValue * value, GParamSpec * pspec)
{
  /* GXPixmap* self = GX_PIXMAP(object); */

  switch (id)
    {
#if 0				/* template code */
    case PROP_NAME:
      g_value_set_int (value, self->priv->property);
      break;
#endif
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, id, pspec);
      break;
    }
}

static void
gx_pixmap_set_property (GObject * object,
			guint property_id,
			const GValue * value, GParamSpec * pspec)
{
  GXPixmap* self = GX_PIXMAP(object);

  switch (property_id)
    {
    case PROP_WRAP_XID:
      self->priv->wrap_construct = g_value_get_boolean (value);
      break;
    case PROP_DEPTH:
      self->priv->depth_construct = g_value_get_uint (value);
      break;
    case PROP_DRAWABLE:
      self->priv->drawable_construct = g_value_get_object (value);
      break;
    case PROP_WIDTH:
      self->priv->width_construct = g_value_get_uint (value);
      break;
    case PROP_HEIGHT:
      self->priv->height_construct = g_value_get_uint (value);
      break;
    default:
      g_warning ("gx_pixmap_set_property on unknown property");
      return;
    }
}

#if 0				/* template code */
static void
gx_pixmap_mydoable_interface_init (gpointer interface, gpointer data)
{
  MyDoableIface *mydoable = interface;
  g_assert (G_TYPE_FROM_INTERFACE (mydoable) == MY_TYPE_MYDOABLE);

  mydoable->method1 = gx_pixmap_method1;
  mydoable->method2 = gx_pixmap_method2;
}
#endif

/* Instance Construction */
static void
gx_pixmap_init (GXPixmap * self)
{
  self->priv = GX_PIXMAP_GET_PRIVATE (self);
  /* populate object here */
}

static GObject *
gx_pixmap_constructor (GType type,
		       guint n_construct_params,
		       GObjectConstructParam *construct_params)
{
  GObject *object;
  GXPixmap *self;
  GXDrawable *drawable;
  GXConnection *connection;
  xcb_connection_t *xcb_connection;
  guint32 xid;
  gboolean is_wrapping_xid = FALSE;
  int i;

  /* If this window is wrapping an existing XID, then we first look
   * for an existing window object to return instead */

  for (i = 0; i < n_construct_params; i++)
    {
      GObjectConstructParam *construct_param = &construct_params[i];
      GParamSpec *pspec = construct_param->pspec;
      if (strcmp (g_param_spec_get_name (pspec), "wrap") == 0)
	{
	  is_wrapping_xid = TRUE;
	  break;
	}
    }

  if (is_wrapping_xid)
    {
      GXPixmap *existing_pixmap;

      for (i = 0; i < n_construct_params; i++)
	{
	  GObjectConstructParam *construct_param = &construct_params[i];
	  GParamSpec *pspec = construct_param->pspec;
	  if (strcmp (g_param_spec_get_name (pspec), "xid") == 0)
	    {
	      xid = g_value_get_uint (construct_param->value);
	      break;
	    }
	}
#warning "Test XID wrapping code!!!"
      /* FIXME - mutex */
      existing_pixmap = g_hash_table_lookup (xid_to_pixmap_map,
					     GUINT_TO_POINTER (xid));
      if (existing_pixmap)
	return g_object_ref (existing_pixmap);
    }

  object = G_OBJECT_CLASS (parent_class)->constructor (type,
						       n_construct_params,
						       construct_params);
  self = GX_PIXMAP (object);
  drawable = GX_DRAWABLE (self);

  connection = gx_drawable_get_connection (drawable);
  g_assert (connection);
  xcb_connection = gx_connection_get_xcb_connection (connection);

  xid = drawable->xid;
  if (!drawable->xid)
    {
      g_assert (!self->priv->wrap_construct);
      drawable->xid = xcb_generate_id (xcb_connection);
    }

  if (!self->priv->wrap_construct)
    {
      xcb_create_pixmap (
	 xcb_connection,
	 self->priv->depth_construct,
	 drawable->xid,
	 gx_drawable_get_xid (self->priv->drawable_construct),
	 self->priv->width_construct,
	 self->priv->height_construct);
    }

  g_object_unref (connection);

  g_hash_table_insert (xid_to_pixmap_map,
		       GUINT_TO_POINTER (drawable->xid),
		       object);
  return object;
}

GXPixmap *
gx_pixmap_new (GXConnection *connection,
	       GXDrawable *reference,
	       guint16 width,
	       guint16 height,
	       guint8 depth)
{
  return GX_PIXMAP (g_object_new (GX_TYPE_PIXMAP,
				  "connection", connection,
				  "drawable", reference,
				  "width", width,
				  "height", height,
				  "depth", depth,
				  NULL));

}

void
gx_pixmap_finalize (GObject * object)
{
  /* GXPixmap *self = GX_PIXMAP(object); */

  /* destruct your object here */
  G_OBJECT_CLASS (parent_class)->finalize (object);
}

GXConnection *
gx_pixmap_get_connection (GXPixmap *self)
{
  return gx_drawable_get_connection (GX_DRAWABLE (self));
}

